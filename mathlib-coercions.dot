strict digraph  {
inhabited [shape=box];
nonempty [shape=box];
setoid [shape=box];
has_equiv [shape=box];
has_sizeof [shape=box];
has_well_founded [shape=box];
has_lift [shape=box];
has_lift_t [shape=box];
has_coe [shape=box];
has_coe_t [shape=box];
has_coe_t_aux [shape=box];
is_commutative [shape=box];
is_symm_op [shape=box];
is_preorder [shape=box];
is_refl [shape=box];
is_trans [shape=box];
is_total_preorder [shape=box];
is_total [shape=box];
is_partial_order [shape=box];
is_antisymm [shape=box];
is_linear_order [shape=box];
is_equiv [shape=box];
is_symm [shape=box];
is_per [shape=box];
is_strict_order [shape=box];
is_irrefl [shape=box];
is_strict_weak_order [shape=box];
is_incomp_trans [shape=box];
is_strict_total_order [shape=box];
is_trichotomous [shape=box];
applicative [shape=box];
functor [shape=box];
has_pure [shape=box];
has_seq [shape=box];
has_seq_left [shape=box];
has_seq_right [shape=box];
preorder [shape=box];
has_le [shape=box];
has_lt [shape=box];
monad [shape=box];
has_bind [shape=box];
partial_order [shape=box];
alternative [shape=box];
has_orelse [shape=box];
linear_order [shape=box];
decidable_linear_order [shape=box];
has_to_format [shape=box];
has_to_tactic_format [shape=box];
is_lawful_applicative [shape=box];
is_lawful_functor [shape=box];
is_lawful_monad [shape=box];
semigroup [shape=box];
has_mul [shape=box];
comm_semigroup [shape=box];
left_cancel_semigroup [shape=box];
right_cancel_semigroup [shape=box];
monoid [shape=box];
has_one [shape=box];
comm_monoid [shape=box];
group [shape=box];
has_inv [shape=box];
comm_group [shape=box];
add_semigroup [shape=box];
has_add [shape=box];
add_comm_semigroup [shape=box];
add_left_cancel_semigroup [shape=box];
add_right_cancel_semigroup [shape=box];
add_monoid [shape=box];
has_zero [shape=box];
add_comm_monoid [shape=box];
add_group [shape=box];
has_neg [shape=box];
add_comm_group [shape=box];
has_sub [shape=box];
distrib [shape=box];
mul_zero_class [shape=box];
zero_ne_one_class [shape=box];
ordered_cancel_comm_monoid [shape=box];
semiring [shape=box];
comm_semiring [shape=box];
has_dvd [shape=box];
ordered_comm_group [shape=box];
ring [shape=box];
comm_ring [shape=box];
no_zero_divisors [shape=box];
integral_domain [shape=box];
division_ring [shape=box];
decidable_linear_ordered_comm_group [shape=box];
decidable_linear_ordered_cancel_comm_monoid [shape=box];
field [shape=box];
discrete_field [shape=box];
ordered_semiring [shape=box];
linear_ordered_semiring [shape=box];
decidable_linear_ordered_semiring [shape=box];
ordered_ring [shape=box];
linear_ordered_ring [shape=box];
linear_ordered_comm_ring [shape=box];
decidable_linear_ordered_comm_ring [shape=box];
linear_ordered_field [shape=box];
discrete_linear_ordered_field [shape=box];
unique [shape=box];
subsingleton [shape=box];
is_comm_applicative [shape=box];
traversable [shape=box];
is_lawful_traversable [shape=box];
"category_theory.category_struct" [shape=box];
"category_theory.has_hom" [shape=box];
"category_theory.category" [shape=box];
bitraversable [shape=box];
bifunctor [shape=box];
is_lawful_bitraversable [shape=box];
is_lawful_bifunctor [shape=box];
is_lawful_monad_cont [shape=box];
"category_theory.is_iso" [shape=box];
"category_theory.epi" [shape=box];
"category_theory.mono" [shape=box];
is_add_monoid_hom [shape=box];
is_add_hom [shape=box];
"is_strict_total_order'" [shape=box];
is_monoid_hom [shape=box];
is_mul_hom [shape=box];
is_order_connected [shape=box];
is_extensional [shape=box];
is_well_order [shape=box];
is_asymm [shape=box];
is_add_group_hom [shape=box];
is_group_hom [shape=box];
directed_order [shape=box];
"lattice.semilattice_sup" [shape=box];
"lattice.has_sup" [shape=box];
"lattice.semilattice_inf" [shape=box];
"lattice.has_inf" [shape=box];
"lattice.lattice" [shape=box];
"lattice.distrib_lattice" [shape=box];
"lattice.order_top" [shape=box];
"lattice.has_top" [shape=box];
"lattice.order_bot" [shape=box];
"lattice.has_bot" [shape=box];
"lattice.semilattice_sup_top" [shape=box];
"lattice.semilattice_sup_bot" [shape=box];
"lattice.semilattice_inf_top" [shape=box];
"lattice.semilattice_inf_bot" [shape=box];
"lattice.bounded_lattice" [shape=box];
"category_theory.groupoid" [shape=box];
"lattice.bounded_distrib_lattice" [shape=box];
"category_theory.concrete_category" [shape=box];
"category_theory.is_equivalence" [shape=box];
"category_theory.faithful" [shape=box];
"category_theory.full" [shape=box];
"lattice.boolean_algebra" [shape=box];
ordered_comm_monoid [shape=box];
canonically_ordered_monoid [shape=box];
is_semiring_hom [shape=box];
is_ring_hom [shape=box];
nonzero_comm_semiring [shape=box];
nonzero_comm_ring [shape=box];
domain [shape=box];
has_div [shape=box];
nonneg_comm_group [shape=box];
nonneg_ring [shape=box];
linear_nonneg_ring [shape=box];
canonically_ordered_comm_semiring [shape=box];
is_ring_anti_hom [shape=box];
"lattice.complete_lattice" [shape=box];
"lattice.has_Sup" [shape=box];
"lattice.has_Inf" [shape=box];
"lattice.complete_linear_order" [shape=box];
"category_theory.reflective" [shape=box];
"category_theory.is_right_adjoint" [shape=box];
"category_theory.monadic_right_adjoint" [shape=box];
"lattice.complete_distrib_lattice" [shape=box];
"lattice.complete_boolean_algebra" [shape=box];
"category_theory.limits.has_limits_of_shape" [shape=box];
"category_theory.limits.has_limit" [shape=box];
"category_theory.limits.has_limits" [shape=box];
euclidean_domain [shape=box];
has_mod [shape=box];
"category_theory.limits.has_colimits_of_shape" [shape=box];
"category_theory.limits.has_colimit" [shape=box];
"category_theory.limits.has_colimits" [shape=box];
"category_theory.limits.preserves_limits_of_shape" [shape=box];
"category_theory.limits.preserves_limit" [shape=box];
"category_theory.limits.preserves_colimits_of_shape" [shape=box];
"category_theory.limits.preserves_colimit" [shape=box];
"category_theory.limits.reflects_limits_of_shape" [shape=box];
"category_theory.limits.reflects_limit" [shape=box];
"category_theory.limits.reflects_colimits_of_shape" [shape=box];
"category_theory.limits.reflects_colimit" [shape=box];
"category_theory.limits.reflects_limits" [shape=box];
"category_theory.limits.reflects_colimits" [shape=box];
"category_theory.limits.preserves_colimits" [shape=box];
"category_theory.limits.preserves_limits" [shape=box];
normalization_domain [shape=box];
gcd_domain [shape=box];
fintype [shape=box];
infinite [shape=box];
denumerable [shape=box];
encodable [shape=box];
"category_theory.limits.fin_category" [shape=box];
"category_theory.limits.has_finite_limits" [shape=box];
"category_theory.limits.has_finite_colimits" [shape=box];
"category_theory.limits.has_products" [shape=box];
"category_theory.limits.has_finite_products" [shape=box];
"category_theory.limits.has_coproducts" [shape=box];
"category_theory.limits.has_finite_coproducts" [shape=box];
"category_theory.limits.has_terminal" [shape=box];
"category_theory.limits.has_initial" [shape=box];
"lattice.conditionally_complete_lattice" [shape=box];
"lattice.conditionally_complete_linear_order" [shape=box];
"lattice.conditionally_complete_linear_order_bot" [shape=box];
primcodable [shape=box];
"category_theory.limits.has_binary_products" [shape=box];
"category_theory.limits.has_binary_coproducts" [shape=box];
is_add_subgroup [shape=box];
is_add_submonoid [shape=box];
is_subgroup [shape=box];
is_submonoid [shape=box];
"topological_space.second_countable_topology" [shape=box];
"topological_space.first_countable_topology" [shape=box];
topological_space [shape=box];
normal_add_subgroup [shape=box];
"topological_space.separable_space" [shape=box];
normal_subgroup [shape=box];
compact_space [shape=box];
irreducible_space [shape=box];
connected_space [shape=box];
totally_separated_space [shape=box];
totally_disconnected_space [shape=box];
sequential_space [shape=box];
t1_space [shape=box];
t0_space [shape=box];
t2_space [shape=box];
discrete_topology [shape=box];
regular_space [shape=box];
normal_space [shape=box];
uniform_space [shape=box];
separated [shape=box];
complete_space [shape=box];
emetric_space [shape=box];
has_edist [shape=box];
is_subring [shape=box];
is_subfield [shape=box];
mul_action [shape=box];
has_scalar [shape=box];
distrib_mul_action [shape=box];
semimodule [shape=box];
module [shape=box];
topological_add_group [shape=box];
topological_add_monoid [shape=box];
topological_group [shape=box];
topological_monoid [shape=box];
add_group_with_zero_nhd [shape=box];
ordered_topology [shape=box];
uniform_add_group [shape=box];
orderable_topology [shape=box];
"ideal.is_maximal" [shape=box];
"ideal.is_prime" [shape=box];
metric_space [shape=box];
has_dist [shape=box];
local_ring [shape=box];
is_local_ring_hom [shape=box];
topological_semiring [shape=box];
topological_ring [shape=box];
proper_space [shape=box];
locally_compact_space [shape=box];
premetric_space [shape=box];
algebra [shape=box];
topological_module [shape=box];
topological_semimodule [shape=box];
lie_ring [shape=box];
has_bracket [shape=box];
lie_algebra [shape=box];
normed_group [shape=box];
has_norm [shape=box];
normed_ring [shape=box];
is_noetherian_ring [shape=box];
is_noetherian [shape=box];
normed_field [shape=box];
nondiscrete_normed_field [shape=box];
principal_ideal_domain [shape=box];
normed_space [shape=box];
normed_algebra [shape=box];
measurable_space [shape=box];
"measure_theory.measure_space" [shape=box];
inner_product_space [shape=box];
has_inner [shape=box];
inhabited -> nonempty;
setoid -> has_equiv;
has_sizeof -> has_well_founded;
has_lift -> has_lift_t;
has_coe -> has_coe_t;
has_coe -> has_coe_t_aux;
has_coe_t -> has_lift_t;
is_commutative -> is_symm_op;
is_preorder -> is_refl;
is_preorder -> is_trans;
is_total_preorder -> is_trans;
is_total_preorder -> is_total;
is_total_preorder -> is_preorder;
is_partial_order -> is_preorder;
is_partial_order -> is_antisymm;
is_linear_order -> is_partial_order;
is_linear_order -> is_total;
is_equiv -> is_preorder;
is_equiv -> is_symm;
is_per -> is_symm;
is_per -> is_trans;
is_strict_order -> is_irrefl;
is_strict_order -> is_trans;
is_strict_weak_order -> is_strict_order;
is_strict_weak_order -> is_incomp_trans;
is_strict_total_order -> is_trichotomous;
is_strict_total_order -> is_strict_weak_order;
applicative -> functor;
applicative -> has_pure;
applicative -> has_seq;
applicative -> has_seq_left;
applicative -> has_seq_right;
applicative -> is_lawful_functor;
applicative -> is_lawful_applicative;
preorder -> has_le;
preorder -> has_lt;
preorder -> "category_theory.category";
monad -> applicative;
monad -> has_bind;
monad -> is_lawful_applicative;
monad -> is_lawful_monad;
partial_order -> preorder;
alternative -> applicative;
alternative -> has_orelse;
linear_order -> partial_order;
decidable_linear_order -> linear_order;
decidable_linear_order -> "lattice.lattice";
decidable_linear_order -> "lattice.distrib_lattice";
has_to_format -> has_to_tactic_format;
semigroup -> has_mul;
comm_semigroup -> semigroup;
left_cancel_semigroup -> semigroup;
right_cancel_semigroup -> semigroup;
monoid -> semigroup;
monoid -> has_one;
monoid -> is_mul_hom;
monoid -> has_scalar;
monoid -> mul_action;
comm_monoid -> monoid;
comm_monoid -> comm_semigroup;
group -> monoid;
group -> has_inv;
group -> left_cancel_semigroup;
group -> right_cancel_semigroup;
group -> is_mul_hom;
group -> is_monoid_hom;
group -> is_submonoid;
group -> is_subgroup;
comm_group -> group;
comm_group -> comm_monoid;
add_semigroup -> has_add;
add_comm_semigroup -> add_semigroup;
add_left_cancel_semigroup -> add_semigroup;
add_right_cancel_semigroup -> add_semigroup;
add_monoid -> add_semigroup;
add_monoid -> has_zero;
add_monoid -> is_add_hom;
add_comm_monoid -> add_monoid;
add_comm_monoid -> add_comm_semigroup;
add_group -> add_monoid;
add_group -> has_neg;
add_group -> add_left_cancel_semigroup;
add_group -> add_right_cancel_semigroup;
add_group -> has_sub;
add_group -> is_add_hom;
add_group -> is_add_monoid_hom;
add_group -> is_add_submonoid;
add_group -> is_add_subgroup;
add_comm_group -> add_group;
add_comm_group -> add_comm_monoid;
add_comm_group -> has_bracket;
distrib -> has_mul;
distrib -> has_add;
mul_zero_class -> has_mul;
mul_zero_class -> has_zero;
zero_ne_one_class -> has_zero;
zero_ne_one_class -> has_one;
ordered_cancel_comm_monoid -> add_comm_monoid;
ordered_cancel_comm_monoid -> add_left_cancel_semigroup;
ordered_cancel_comm_monoid -> add_right_cancel_semigroup;
ordered_cancel_comm_monoid -> partial_order;
ordered_cancel_comm_monoid -> ordered_comm_monoid;
semiring -> add_comm_monoid;
semiring -> monoid;
semiring -> distrib;
semiring -> mul_zero_class;
semiring -> is_add_monoid_hom;
semiring -> is_monoid_hom;
semiring -> distrib_mul_action;
comm_semiring -> semiring;
comm_semiring -> comm_monoid;
comm_semiring -> has_dvd;
ordered_comm_group -> add_comm_group;
ordered_comm_group -> partial_order;
ordered_comm_group -> ordered_cancel_comm_monoid;
ring -> add_comm_group;
ring -> monoid;
ring -> distrib;
ring -> semiring;
ring -> is_semiring_hom;
ring -> is_add_group_hom;
ring -> is_add_subgroup;
ring -> is_submonoid;
ring -> semimodule;
ring -> topological_semimodule;
ring -> is_noetherian;
comm_ring -> ring;
comm_ring -> comm_semigroup;
comm_ring -> comm_semiring;
comm_ring -> "ideal.is_prime";
comm_ring -> is_ring_hom;
comm_ring -> has_scalar;
comm_ring -> module;
comm_ring -> lie_ring;
no_zero_divisors -> has_mul;
no_zero_divisors -> has_zero;
integral_domain -> comm_ring;
integral_domain -> no_zero_divisors;
integral_domain -> zero_ne_one_class;
integral_domain -> nonzero_comm_ring;
integral_domain -> domain;
division_ring -> ring;
division_ring -> has_inv;
division_ring -> zero_ne_one_class;
division_ring -> has_div;
division_ring -> domain;
decidable_linear_ordered_comm_group -> add_comm_group;
decidable_linear_ordered_comm_group -> decidable_linear_order;
decidable_linear_ordered_comm_group -> ordered_comm_group;
decidable_linear_ordered_comm_group -> decidable_linear_ordered_cancel_comm_monoid;
decidable_linear_ordered_cancel_comm_monoid -> ordered_cancel_comm_monoid;
decidable_linear_ordered_cancel_comm_monoid -> decidable_linear_order;
field -> division_ring;
field -> comm_ring;
field -> integral_domain;
discrete_field -> field;
discrete_field -> euclidean_domain;
discrete_field -> is_subring;
discrete_field -> local_ring;
ordered_semiring -> semiring;
ordered_semiring -> ordered_cancel_comm_monoid;
linear_ordered_semiring -> ordered_semiring;
linear_ordered_semiring -> linear_order;
decidable_linear_ordered_semiring -> linear_ordered_semiring;
decidable_linear_ordered_semiring -> decidable_linear_order;
ordered_ring -> ring;
ordered_ring -> ordered_comm_group;
ordered_ring -> zero_ne_one_class;
ordered_ring -> ordered_semiring;
linear_ordered_ring -> ordered_ring;
linear_ordered_ring -> linear_order;
linear_ordered_ring -> linear_ordered_semiring;
linear_ordered_ring -> domain;
linear_ordered_comm_ring -> linear_ordered_ring;
linear_ordered_comm_ring -> comm_monoid;
linear_ordered_comm_ring -> integral_domain;
decidable_linear_ordered_comm_ring -> linear_ordered_comm_ring;
decidable_linear_ordered_comm_ring -> decidable_linear_ordered_comm_group;
decidable_linear_ordered_comm_ring -> decidable_linear_ordered_semiring;
linear_ordered_field -> linear_ordered_ring;
linear_ordered_field -> field;
discrete_linear_ordered_field -> linear_ordered_field;
discrete_linear_ordered_field -> decidable_linear_ordered_comm_ring;
discrete_linear_ordered_field -> discrete_field;
unique -> inhabited;
unique -> subsingleton;
unique -> fintype;
traversable -> functor;
traversable -> is_lawful_functor;
"category_theory.category_struct" -> "category_theory.has_hom";
"category_theory.category" -> "category_theory.category_struct";
"category_theory.category" -> "category_theory.epi";
"category_theory.category" -> "category_theory.mono";
"category_theory.category" -> "category_theory.faithful";
"category_theory.category" -> "category_theory.full";
"category_theory.category" -> "category_theory.is_right_adjoint";
"category_theory.category" -> "category_theory.monadic_right_adjoint";
"category_theory.category" -> "category_theory.limits.has_limit";
"category_theory.category" -> "category_theory.limits.has_limits_of_shape";
"category_theory.category" -> "category_theory.limits.has_colimit";
"category_theory.category" -> "category_theory.limits.has_colimits_of_shape";
"category_theory.category" -> "category_theory.limits.preserves_limit";
"category_theory.category" -> "category_theory.limits.preserves_limits_of_shape";
"category_theory.category" -> "category_theory.limits.preserves_colimit";
"category_theory.category" -> "category_theory.limits.preserves_colimits_of_shape";
"category_theory.category" -> "category_theory.limits.reflects_limit";
"category_theory.category" -> "category_theory.limits.reflects_colimit";
"category_theory.category" -> "category_theory.limits.reflects_limits_of_shape";
"category_theory.category" -> "category_theory.limits.reflects_colimits_of_shape";
"category_theory.category" -> "category_theory.limits.preserves_colimits";
"category_theory.category" -> "category_theory.limits.preserves_limits";
"category_theory.category" -> fintype;
"category_theory.category" -> "category_theory.limits.has_finite_limits";
"category_theory.category" -> "category_theory.limits.has_finite_colimits";
"category_theory.category" -> "category_theory.limits.has_finite_products";
"category_theory.category" -> "category_theory.limits.has_finite_coproducts";
"category_theory.category" -> "category_theory.limits.has_terminal";
"category_theory.category" -> "category_theory.limits.has_initial";
"category_theory.category" -> "category_theory.limits.has_binary_products";
"category_theory.category" -> "category_theory.limits.has_binary_coproducts";
bitraversable -> bifunctor;
bitraversable -> is_lawful_bifunctor;
"is_strict_total_order'" -> is_trichotomous;
"is_strict_total_order'" -> is_strict_order;
"is_strict_total_order'" -> is_order_connected;
"is_strict_total_order'" -> is_strict_total_order;
"is_strict_total_order'" -> is_extensional;
is_well_order -> "is_strict_total_order'";
is_well_order -> is_strict_total_order;
is_well_order -> is_extensional;
is_well_order -> is_trichotomous;
is_well_order -> is_trans;
is_well_order -> is_irrefl;
is_well_order -> is_asymm;
directed_order -> preorder;
"lattice.semilattice_sup" -> "lattice.has_sup";
"lattice.semilattice_sup" -> partial_order;
"lattice.semilattice_inf" -> "lattice.has_inf";
"lattice.semilattice_inf" -> partial_order;
"lattice.lattice" -> "lattice.semilattice_sup";
"lattice.lattice" -> "lattice.semilattice_inf";
"lattice.distrib_lattice" -> "lattice.lattice";
"lattice.order_top" -> "lattice.has_top";
"lattice.order_top" -> partial_order;
"lattice.order_bot" -> "lattice.has_bot";
"lattice.order_bot" -> partial_order;
"lattice.semilattice_sup_top" -> "lattice.order_top";
"lattice.semilattice_sup_top" -> "lattice.semilattice_sup";
"lattice.semilattice_sup_bot" -> "lattice.order_bot";
"lattice.semilattice_sup_bot" -> "lattice.semilattice_sup";
"lattice.semilattice_inf_top" -> "lattice.order_top";
"lattice.semilattice_inf_top" -> "lattice.semilattice_inf";
"lattice.semilattice_inf_bot" -> "lattice.order_bot";
"lattice.semilattice_inf_bot" -> "lattice.semilattice_inf";
"lattice.bounded_lattice" -> "lattice.lattice";
"lattice.bounded_lattice" -> "lattice.order_top";
"lattice.bounded_lattice" -> "lattice.order_bot";
"lattice.bounded_lattice" -> "lattice.semilattice_inf_top";
"lattice.bounded_lattice" -> "lattice.semilattice_inf_bot";
"lattice.bounded_lattice" -> "lattice.semilattice_sup_top";
"lattice.bounded_lattice" -> "lattice.semilattice_sup_bot";
"category_theory.groupoid" -> "category_theory.category";
"lattice.bounded_distrib_lattice" -> "lattice.distrib_lattice";
"lattice.bounded_distrib_lattice" -> "lattice.bounded_lattice";
"category_theory.concrete_category" -> "category_theory.category";
"lattice.boolean_algebra" -> "lattice.bounded_distrib_lattice";
"lattice.boolean_algebra" -> has_neg;
"lattice.boolean_algebra" -> has_sub;
ordered_comm_monoid -> add_comm_monoid;
ordered_comm_monoid -> partial_order;
canonically_ordered_monoid -> ordered_comm_monoid;
canonically_ordered_monoid -> "lattice.order_bot";
nonzero_comm_semiring -> comm_semiring;
nonzero_comm_semiring -> zero_ne_one_class;
nonzero_comm_ring -> comm_ring;
nonzero_comm_ring -> zero_ne_one_class;
nonzero_comm_ring -> nonzero_comm_semiring;
domain -> ring;
domain -> no_zero_divisors;
domain -> zero_ne_one_class;
nonneg_comm_group -> add_comm_group;
nonneg_comm_group -> ordered_comm_group;
nonneg_ring -> ring;
nonneg_ring -> zero_ne_one_class;
nonneg_ring -> nonneg_comm_group;
nonneg_ring -> ordered_ring;
linear_nonneg_ring -> domain;
linear_nonneg_ring -> nonneg_comm_group;
linear_nonneg_ring -> nonneg_ring;
linear_nonneg_ring -> linear_order;
linear_nonneg_ring -> linear_ordered_ring;
canonically_ordered_comm_semiring -> canonically_ordered_monoid;
canonically_ordered_comm_semiring -> comm_semiring;
canonically_ordered_comm_semiring -> zero_ne_one_class;
"lattice.complete_lattice" -> "lattice.bounded_lattice";
"lattice.complete_lattice" -> "lattice.has_Sup";
"lattice.complete_lattice" -> "lattice.has_Inf";
"lattice.complete_lattice" -> "lattice.conditionally_complete_lattice";
"lattice.complete_linear_order" -> "lattice.complete_lattice";
"lattice.complete_linear_order" -> decidable_linear_order;
"lattice.complete_linear_order" -> "lattice.conditionally_complete_linear_order";
"lattice.complete_distrib_lattice" -> "lattice.complete_lattice";
"lattice.complete_distrib_lattice" -> "lattice.bounded_distrib_lattice";
"lattice.complete_boolean_algebra" -> "lattice.boolean_algebra";
"lattice.complete_boolean_algebra" -> "lattice.complete_distrib_lattice";
euclidean_domain -> nonzero_comm_ring;
euclidean_domain -> has_div;
euclidean_domain -> has_mod;
euclidean_domain -> integral_domain;
euclidean_domain -> principal_ideal_domain;
normalization_domain -> integral_domain;
gcd_domain -> normalization_domain;
fintype -> is_noetherian;
infinite -> nonempty;
denumerable -> encodable;
denumerable -> primcodable;
"lattice.conditionally_complete_lattice" -> "lattice.lattice";
"lattice.conditionally_complete_lattice" -> "lattice.has_Sup";
"lattice.conditionally_complete_lattice" -> "lattice.has_Inf";
"lattice.conditionally_complete_linear_order" -> "lattice.conditionally_complete_lattice";
"lattice.conditionally_complete_linear_order" -> decidable_linear_order;
"lattice.conditionally_complete_linear_order_bot" -> "lattice.conditionally_complete_lattice";
"lattice.conditionally_complete_linear_order_bot" -> decidable_linear_order;
"lattice.conditionally_complete_linear_order_bot" -> "lattice.order_bot";
primcodable -> encodable;
topological_space -> "topological_space.first_countable_topology";
topological_space -> "topological_space.separable_space";
topological_space -> compact_space;
topological_space -> connected_space;
topological_space -> totally_disconnected_space;
topological_space -> sequential_space;
topological_space -> t0_space;
topological_space -> t1_space;
topological_space -> t2_space;
topological_space -> regular_space;
topological_space -> topological_add_monoid;
topological_space -> topological_monoid;
topological_space -> ordered_topology;
topological_space -> topological_semiring;
topological_space -> topological_add_group;
topological_space -> measurable_space;
uniform_space -> topological_space;
uniform_space -> t2_space;
uniform_space -> regular_space;
uniform_space -> complete_space;
uniform_space -> topological_add_group;
emetric_space -> has_edist;
emetric_space -> uniform_space;
add_group_with_zero_nhd -> add_comm_group;
add_group_with_zero_nhd -> topological_space;
metric_space -> has_dist;
metric_space -> uniform_space;
metric_space -> has_edist;
metric_space -> emetric_space;
metric_space -> proper_space;
metric_space -> locally_compact_space;
metric_space -> complete_space;
metric_space -> "topological_space.second_countable_topology";
local_ring -> nonzero_comm_ring;
premetric_space -> has_dist;
normed_group -> has_norm;
normed_group -> add_comm_group;
normed_group -> metric_space;
normed_ring -> has_norm;
normed_ring -> ring;
normed_ring -> metric_space;
normed_ring -> normed_group;
normed_field -> has_norm;
normed_field -> discrete_field;
normed_field -> metric_space;
normed_field -> normed_ring;
normed_field -> module;
normed_field -> algebra;
nondiscrete_normed_field -> normed_field;
principal_ideal_domain -> integral_domain;
"measure_theory.measure_space" -> measurable_space;
inner_product_space -> add_comm_group;
inner_product_space -> has_inner;
inner_product_space -> has_norm;
inner_product_space -> normed_group;
}
